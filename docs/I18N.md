# Мультиязычность (i18n)

## Поддерживаемые локали

- **en-US** - English (United States)
- **fr-CA** - French (Canada)
- **en-CA** - English (Canada) - **по умолчанию**

## Архитектура

### 1. Утилиты локали

`lib/utils/locale.ts` предоставляет:
- `getLocaleFromContext(ctx)` - получение локали из контекста Next.js
- `SupportedLocale` - тип для поддерживаемых локалей
- `localeToStrapiLocale(locale)` - конвертация локали для Strapi
- `DEFAULT_LOCALE` - дефолтная локаль (`en-CA`)

### 2. Определение локали

Локаль определяется в следующем порядке приоритета:

1. **Query параметр** `?locale=en-US`
2. **Cookie** `locale=en-CA`
3. **Accept-Language header** (парсится автоматически)
4. **Дефолтная локаль** `en-CA`

### 3. Использование в getServerSideProps

```typescript
import { getLocaleFromContext } from '@/lib/utils/locale';
import { fetchVideos } from '@/lib/api/videos';

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  // Получаем локаль из контекста
  const locale = getLocaleFromContext(ctx);
  
  // Передаем локаль в API функции
  const videos = await fetchVideos(locale);
  
  return {
    props: {
      videos,
    },
  };
};
```

### 4. API функции

Все API функции принимают `locale: SupportedLocale`:

```typescript
// lib/api/videos.ts
export async function fetchVideos(
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<VideoItem[]>

// lib/api/catalogues.ts
export async function fetchCatalogues(
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<CatalogEntry[]>

// lib/api/promos.ts
export async function fetchPromos(
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<PromoItem[]>

// lib/api/priceLists.ts
export async function fetchPriceLists(
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<PriceListItem[]>

// lib/api/products.ts
export async function fetchProducts(
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<Product[]>

export async function fetchProductBySku(
  sku: string,
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<Product | null>

// lib/api/brands.ts
export async function fetchProductsByBrandSlug(
  brandSlug: string,
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<BrandProduct[]>

export async function getBrandDataBySlug(
  brandSlug: string,
  locale: SupportedLocale = DEFAULT_LOCALE
): Promise<BrandData | null>
```

### 5. Strapi запросы

Локаль передается в Strapi через query параметр:

```
/api/videos?populate=*&locale=en-US
/api/videos?populate=*&locale=fr-CA
/api/videos?populate=*&locale=en-CA
```

Функция `localeToStrapiLocale()` передает локаль как есть - без преобразований.
Strapi и фронт должны быть настроены на одинаковые локали (en-US, fr-CA, en-CA).

### 6. Переключение языка в UI

В `components/Header.tsx` реализовано переключение языка через селектор.
При выборе языка можно:
- Сохранять в cookie `locale`
- Обновлять URL с query параметром `?locale=...`
- Обновлять страницу для применения новой локали

**TODO**: Реализовать сохранение выбранной локали в cookie и автоматическое применение.

## Примеры

### Получение локали из cookie

```typescript
// В getServerSideProps
const locale = getLocaleFromContext(ctx);
// Проверяет: query → cookie → header → default
```

### Передача локали в API

```typescript
const locale = getLocaleFromContext(ctx);
const videos = await fetchVideos(locale);
const products = await fetchProducts(locale);
```

### Использование в компонентах

```typescript
// На клиенте можно использовать useRouter для получения locale из query
import { useRouter } from 'next/router';

const router = useRouter();
const locale = (router.query.locale as SupportedLocale) || DEFAULT_LOCALE;
```

## Настройка Strapi

В Strapi нужно настроить локали в админ-панели:
1. Settings → Internationalization
2. Добавить локали: `en-US`, `fr-CA`, `en-CA`
3. Убедиться, что контент создается для каждой локали

## Следующие шаги

1. ✅ Базовая инфраструктура локалей
2. ✅ Интеграция с API функциями
3. ✅ Использование в getServerSideProps
4. ⏳ Сохранение выбранной локали в cookie
5. ⏳ Автоматическое применение локали при переключении
6. ⏳ Локализация UI текстов (если нужно)
